{"version":3,"sources":["src/prism/prism.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ,sCAAsC,sBAAsB;AAC5D;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,wCAAwC,oBAAoB;AAC5D;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,+BAA+B,wBAAwB,EAAE;AACzD;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,YAAY;;AAEZ;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,wBAAwB,yBAAyB;AACjD;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,uCAAuC,mBAAmB;;AAE1D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mCAAmC,mEAAmE;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,EAAE;;AAEF;AACA,SAAS;;AAET;AACA;;AAEA;;AAEA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA,0BAA0B,2BAA2B;AACrD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,yEAAyE;AACzE,EAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,oBAAoB,IAAI;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA,0GAA0G,EAAE;AAC5G,CAAC;;AAED;AACA;AACA,uEAAuE,IAAI,kBAAkB;AAC7F;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,GAAG,IAAI;AACzB;AACA;AACA,qBAAqB,GAAG;AACxB;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,gBAAgB;AAC5B;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,oCAAoC,eAAe;AACnD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B;AAC1B;;AAEA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,qCAAqC,eAAe;AACpD,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;;AAEA,8BAA8B,2BAA2B,EAAE;;AAE3D;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA,iBAAiB,kBAAkB;AACnC;AACA;;AAEA;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,qBAAqB;AACrC;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA,IAAI;AACJ;AACA;;AAEA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,EAAE;AACF,CAAC","file":"scripts.bundle.js","sourcesContent":["/* PrismJS 1.10.0\r\nhttp://prismjs.com/download.html?themes=prism-okaidia&languages=clike+javascript&plugins=line-numbers+toolbar+unescaped-markup+normalize-whitespace+copy-to-clipboard */\r\nvar _self = (typeof window !== 'undefined')\r\n\t? window   // if in browser\r\n\t: (\r\n\t\t(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)\r\n\t\t? self // if in worker\r\n\t\t: {}   // if in node js\r\n\t);\r\n\r\n/**\r\n * Prism: Lightweight, robust, elegant syntax highlighting\r\n * MIT license http://www.opensource.org/licenses/mit-license.php/\r\n * @author Lea Verou http://lea.verou.me\r\n */\r\n\r\nvar Prism = (function(){\r\n\r\n// Private helper vars\r\nvar lang = /\\blang(?:uage)?-(\\w+)\\b/i;\r\nvar uniqueId = 0;\r\n\r\nvar _ = _self.Prism = {\r\n\tmanual: _self.Prism && _self.Prism.manual,\r\n\tdisableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,\r\n\tutil: {\r\n\t\tencode: function (tokens) {\r\n\t\t\tif (tokens instanceof Token) {\r\n\t\t\t\treturn new Token(tokens.type, _.util.encode(tokens.content), tokens.alias);\r\n\t\t\t} else if (_.util.type(tokens) === 'Array') {\r\n\t\t\t\treturn tokens.map(_.util.encode);\r\n\t\t\t} else {\r\n\t\t\t\treturn tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\\u00a0/g, ' ');\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\ttype: function (o) {\r\n\t\t\treturn Object.prototype.toString.call(o).match(/\\[object (\\w+)\\]/)[1];\r\n\t\t},\r\n\r\n\t\tobjId: function (obj) {\r\n\t\t\tif (!obj['__id']) {\r\n\t\t\t\tObject.defineProperty(obj, '__id', { value: ++uniqueId });\r\n\t\t\t}\r\n\t\t\treturn obj['__id'];\r\n\t\t},\r\n\r\n\t\t// Deep clone a language definition (e.g. to extend it)\r\n\t\tclone: function (o) {\r\n\t\t\tvar type = _.util.type(o);\r\n\r\n\t\t\tswitch (type) {\r\n\t\t\t\tcase 'Object':\r\n\t\t\t\t\tvar clone = {};\r\n\r\n\t\t\t\t\tfor (var key in o) {\r\n\t\t\t\t\t\tif (o.hasOwnProperty(key)) {\r\n\t\t\t\t\t\t\tclone[key] = _.util.clone(o[key]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn clone;\r\n\r\n\t\t\t\tcase 'Array':\r\n\t\t\t\t\treturn o.map(function(v) { return _.util.clone(v); });\r\n\t\t\t}\r\n\r\n\t\t\treturn o;\r\n\t\t}\r\n\t},\r\n\r\n\tlanguages: {\r\n\t\textend: function (id, redef) {\r\n\t\t\tvar lang = _.util.clone(_.languages[id]);\r\n\r\n\t\t\tfor (var key in redef) {\r\n\t\t\t\tlang[key] = redef[key];\r\n\t\t\t}\r\n\r\n\t\t\treturn lang;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Insert a token before another token in a language literal\r\n\t\t * As this needs to recreate the object (we cannot actually insert before keys in object literals),\r\n\t\t * we cannot just provide an object, we need anobject and a key.\r\n\t\t * @param inside The key (or language id) of the parent\r\n\t\t * @param before The key to insert before. If not provided, the function appends instead.\r\n\t\t * @param insert Object with the key/value pairs to insert\r\n\t\t * @param root The object that contains `inside`. If equal to Prism.languages, it can be omitted.\r\n\t\t */\r\n\t\tinsertBefore: function (inside, before, insert, root) {\r\n\t\t\troot = root || _.languages;\r\n\t\t\tvar grammar = root[inside];\r\n\r\n\t\t\tif (arguments.length == 2) {\r\n\t\t\t\tinsert = arguments[1];\r\n\r\n\t\t\t\tfor (var newToken in insert) {\r\n\t\t\t\t\tif (insert.hasOwnProperty(newToken)) {\r\n\t\t\t\t\t\tgrammar[newToken] = insert[newToken];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn grammar;\r\n\t\t\t}\r\n\r\n\t\t\tvar ret = {};\r\n\r\n\t\t\tfor (var token in grammar) {\r\n\r\n\t\t\t\tif (grammar.hasOwnProperty(token)) {\r\n\r\n\t\t\t\t\tif (token == before) {\r\n\r\n\t\t\t\t\t\tfor (var newToken in insert) {\r\n\r\n\t\t\t\t\t\t\tif (insert.hasOwnProperty(newToken)) {\r\n\t\t\t\t\t\t\t\tret[newToken] = insert[newToken];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tret[token] = grammar[token];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Update references in other language definitions\r\n\t\t\t_.languages.DFS(_.languages, function(key, value) {\r\n\t\t\t\tif (value === root[inside] && key != inside) {\r\n\t\t\t\t\tthis[key] = ret;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\treturn root[inside] = ret;\r\n\t\t},\r\n\r\n\t\t// Traverse a language definition with Depth First Search\r\n\t\tDFS: function(o, callback, type, visited) {\r\n\t\t\tvisited = visited || {};\r\n\t\t\tfor (var i in o) {\r\n\t\t\t\tif (o.hasOwnProperty(i)) {\r\n\t\t\t\t\tcallback.call(o, i, o[i], type || i);\r\n\r\n\t\t\t\t\tif (_.util.type(o[i]) === 'Object' && !visited[_.util.objId(o[i])]) {\r\n\t\t\t\t\t\tvisited[_.util.objId(o[i])] = true;\r\n\t\t\t\t\t\t_.languages.DFS(o[i], callback, null, visited);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (_.util.type(o[i]) === 'Array' && !visited[_.util.objId(o[i])]) {\r\n\t\t\t\t\t\tvisited[_.util.objId(o[i])] = true;\r\n\t\t\t\t\t\t_.languages.DFS(o[i], callback, i, visited);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\tplugins: {},\r\n\r\n\thighlightAll: function(async, callback) {\r\n\t\t_.highlightAllUnder(document, async, callback);\r\n\t},\r\n\r\n\thighlightAllUnder: function(container, async, callback) {\r\n\t\tvar env = {\r\n\t\t\tcallback: callback,\r\n\t\t\tselector: 'code[class*=\"language-\"], [class*=\"language-\"] code, code[class*=\"lang-\"], [class*=\"lang-\"] code'\r\n\t\t};\r\n\r\n\t\t_.hooks.run(\"before-highlightall\", env);\r\n\r\n\t\tvar elements = env.elements || container.querySelectorAll(env.selector);\r\n\r\n\t\tfor (var i=0, element; element = elements[i++];) {\r\n\t\t\t_.highlightElement(element, async === true, env.callback);\r\n\t\t}\r\n\t},\r\n\r\n\thighlightElement: function(element, async, callback) {\r\n\t\t// Find language\r\n\t\tvar language, grammar, parent = element;\r\n\r\n\t\twhile (parent && !lang.test(parent.className)) {\r\n\t\t\tparent = parent.parentNode;\r\n\t\t}\r\n\r\n\t\tif (parent) {\r\n\t\t\tlanguage = (parent.className.match(lang) || [,''])[1].toLowerCase();\r\n\t\t\tgrammar = _.languages[language];\r\n\t\t}\r\n\r\n\t\t// Set language on the element, if not present\r\n\t\telement.className = element.className.replace(lang, '').replace(/\\s+/g, ' ') + ' language-' + language;\r\n\r\n\t\tif (element.parentNode) {\r\n\t\t\t// Set language on the parent, for styling\r\n\t\t\tparent = element.parentNode;\r\n\r\n\t\t\tif (/pre/i.test(parent.nodeName)) {\r\n\t\t\t\tparent.className = parent.className.replace(lang, '').replace(/\\s+/g, ' ') + ' language-' + language;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar code = element.textContent;\r\n\r\n\t\tvar env = {\r\n\t\t\telement: element,\r\n\t\t\tlanguage: language,\r\n\t\t\tgrammar: grammar,\r\n\t\t\tcode: code\r\n\t\t};\r\n\r\n\t\t_.hooks.run('before-sanity-check', env);\r\n\r\n\t\tif (!env.code || !env.grammar) {\r\n\t\t\tif (env.code) {\r\n\t\t\t\t_.hooks.run('before-highlight', env);\r\n\t\t\t\tenv.element.textContent = env.code;\r\n\t\t\t\t_.hooks.run('after-highlight', env);\r\n\t\t\t}\r\n\t\t\t_.hooks.run('complete', env);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t_.hooks.run('before-highlight', env);\r\n\r\n\t\tif (async && _self.Worker) {\r\n\t\t\tvar worker = new Worker(_.filename);\r\n\r\n\t\t\tworker.onmessage = function(evt) {\r\n\t\t\t\tenv.highlightedCode = evt.data;\r\n\r\n\t\t\t\t_.hooks.run('before-insert', env);\r\n\r\n\t\t\t\tenv.element.innerHTML = env.highlightedCode;\r\n\r\n\t\t\t\tcallback && callback.call(env.element);\r\n\t\t\t\t_.hooks.run('after-highlight', env);\r\n\t\t\t\t_.hooks.run('complete', env);\r\n\t\t\t};\r\n\r\n\t\t\tworker.postMessage(JSON.stringify({\r\n\t\t\t\tlanguage: env.language,\r\n\t\t\t\tcode: env.code,\r\n\t\t\t\timmediateClose: true\r\n\t\t\t}));\r\n\t\t}\r\n\t\telse {\r\n\t\t\tenv.highlightedCode = _.highlight(env.code, env.grammar, env.language);\r\n\r\n\t\t\t_.hooks.run('before-insert', env);\r\n\r\n\t\t\tenv.element.innerHTML = env.highlightedCode;\r\n\r\n\t\t\tcallback && callback.call(element);\r\n\r\n\t\t\t_.hooks.run('after-highlight', env);\r\n\t\t\t_.hooks.run('complete', env);\r\n\t\t}\r\n\t},\r\n\r\n\thighlight: function (text, grammar, language) {\r\n\t\tvar tokens = _.tokenize(text, grammar);\r\n\t\treturn Token.stringify(_.util.encode(tokens), language);\r\n\t},\r\n\r\n\tmatchGrammar: function (text, strarr, grammar, index, startPos, oneshot, target) {\r\n\t\tvar Token = _.Token;\r\n\r\n\t\tfor (var token in grammar) {\r\n\t\t\tif(!grammar.hasOwnProperty(token) || !grammar[token]) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tif (token == target) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tvar patterns = grammar[token];\r\n\t\t\tpatterns = (_.util.type(patterns) === \"Array\") ? patterns : [patterns];\r\n\r\n\t\t\tfor (var j = 0; j < patterns.length; ++j) {\r\n\t\t\t\tvar pattern = patterns[j],\r\n\t\t\t\t\tinside = pattern.inside,\r\n\t\t\t\t\tlookbehind = !!pattern.lookbehind,\r\n\t\t\t\t\tgreedy = !!pattern.greedy,\r\n\t\t\t\t\tlookbehindLength = 0,\r\n\t\t\t\t\talias = pattern.alias;\r\n\r\n\t\t\t\tif (greedy && !pattern.pattern.global) {\r\n\t\t\t\t\t// Without the global flag, lastIndex won't work\r\n\t\t\t\t\tvar flags = pattern.pattern.toString().match(/[imuy]*$/)[0];\r\n\t\t\t\t\tpattern.pattern = RegExp(pattern.pattern.source, flags + \"g\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\tpattern = pattern.pattern || pattern;\r\n\r\n\t\t\t\t// Don’t cache length as it changes during the loop\r\n\t\t\t\tfor (var i = index, pos = startPos; i < strarr.length; pos += strarr[i].length, ++i) {\r\n\r\n\t\t\t\t\tvar str = strarr[i];\r\n\r\n\t\t\t\t\tif (strarr.length > text.length) {\r\n\t\t\t\t\t\t// Something went terribly wrong, ABORT, ABORT!\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (str instanceof Token) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tpattern.lastIndex = 0;\r\n\r\n\t\t\t\t\tvar match = pattern.exec(str),\r\n\t\t\t\t\t    delNum = 1;\r\n\r\n\t\t\t\t\t// Greedy patterns can override/remove up to two previously matched tokens\r\n\t\t\t\t\tif (!match && greedy && i != strarr.length - 1) {\r\n\t\t\t\t\t\tpattern.lastIndex = pos;\r\n\t\t\t\t\t\tmatch = pattern.exec(text);\r\n\t\t\t\t\t\tif (!match) {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvar from = match.index + (lookbehind ? match[1].length : 0),\r\n\t\t\t\t\t\t    to = match.index + match[0].length,\r\n\t\t\t\t\t\t    k = i,\r\n\t\t\t\t\t\t    p = pos;\r\n\r\n\t\t\t\t\t\tfor (var len = strarr.length; k < len && (p < to || (!strarr[k].type && !strarr[k - 1].greedy)); ++k) {\r\n\t\t\t\t\t\t\tp += strarr[k].length;\r\n\t\t\t\t\t\t\t// Move the index i to the element in strarr that is closest to from\r\n\t\t\t\t\t\t\tif (from >= p) {\r\n\t\t\t\t\t\t\t\t++i;\r\n\t\t\t\t\t\t\t\tpos = p;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t/*\r\n\t\t\t\t\t\t * If strarr[i] is a Token, then the match starts inside another Token, which is invalid\r\n\t\t\t\t\t\t * If strarr[k - 1] is greedy we are in conflict with another greedy pattern\r\n\t\t\t\t\t\t */\r\n\t\t\t\t\t\tif (strarr[i] instanceof Token || strarr[k - 1].greedy) {\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Number of tokens to delete and replace with the new match\r\n\t\t\t\t\t\tdelNum = k - i;\r\n\t\t\t\t\t\tstr = text.slice(pos, p);\r\n\t\t\t\t\t\tmatch.index -= pos;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (!match) {\r\n\t\t\t\t\t\tif (oneshot) {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif(lookbehind) {\r\n\t\t\t\t\t\tlookbehindLength = match[1].length;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvar from = match.index + lookbehindLength,\r\n\t\t\t\t\t    match = match[0].slice(lookbehindLength),\r\n\t\t\t\t\t    to = from + match.length,\r\n\t\t\t\t\t    before = str.slice(0, from),\r\n\t\t\t\t\t    after = str.slice(to);\r\n\r\n\t\t\t\t\tvar args = [i, delNum];\r\n\r\n\t\t\t\t\tif (before) {\r\n\t\t\t\t\t\t++i;\r\n\t\t\t\t\t\tpos += before.length;\r\n\t\t\t\t\t\targs.push(before);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvar wrapped = new Token(token, inside? _.tokenize(match, inside) : match, alias, match, greedy);\r\n\r\n\t\t\t\t\targs.push(wrapped);\r\n\r\n\t\t\t\t\tif (after) {\r\n\t\t\t\t\t\targs.push(after);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tArray.prototype.splice.apply(strarr, args);\r\n\r\n\t\t\t\t\tif (delNum != 1)\r\n\t\t\t\t\t\t_.matchGrammar(text, strarr, grammar, i, pos, true, token);\r\n\r\n\t\t\t\t\tif (oneshot)\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\ttokenize: function(text, grammar, language) {\r\n\t\tvar strarr = [text];\r\n\r\n\t\tvar rest = grammar.rest;\r\n\r\n\t\tif (rest) {\r\n\t\t\tfor (var token in rest) {\r\n\t\t\t\tgrammar[token] = rest[token];\r\n\t\t\t}\r\n\r\n\t\t\tdelete grammar.rest;\r\n\t\t}\r\n\r\n\t\t_.matchGrammar(text, strarr, grammar, 0, 0, false);\r\n\r\n\t\treturn strarr;\r\n\t},\r\n\r\n\thooks: {\r\n\t\tall: {},\r\n\r\n\t\tadd: function (name, callback) {\r\n\t\t\tvar hooks = _.hooks.all;\r\n\r\n\t\t\thooks[name] = hooks[name] || [];\r\n\r\n\t\t\thooks[name].push(callback);\r\n\t\t},\r\n\r\n\t\trun: function (name, env) {\r\n\t\t\tvar callbacks = _.hooks.all[name];\r\n\r\n\t\t\tif (!callbacks || !callbacks.length) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tfor (var i=0, callback; callback = callbacks[i++];) {\r\n\t\t\t\tcallback(env);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n};\r\n\r\nvar Token = _.Token = function(type, content, alias, matchedStr, greedy) {\r\n\tthis.type = type;\r\n\tthis.content = content;\r\n\tthis.alias = alias;\r\n\t// Copy of the full string this token was created from\r\n\tthis.length = (matchedStr || \"\").length|0;\r\n\tthis.greedy = !!greedy;\r\n};\r\n\r\nToken.stringify = function(o, language, parent) {\r\n\tif (typeof o == 'string') {\r\n\t\treturn o;\r\n\t}\r\n\r\n\tif (_.util.type(o) === 'Array') {\r\n\t\treturn o.map(function(element) {\r\n\t\t\treturn Token.stringify(element, language, o);\r\n\t\t}).join('');\r\n\t}\r\n\r\n\tvar env = {\r\n\t\ttype: o.type,\r\n\t\tcontent: Token.stringify(o.content, language, parent),\r\n\t\ttag: 'span',\r\n\t\tclasses: ['token', o.type],\r\n\t\tattributes: {},\r\n\t\tlanguage: language,\r\n\t\tparent: parent\r\n\t};\r\n\r\n\tif (o.alias) {\r\n\t\tvar aliases = _.util.type(o.alias) === 'Array' ? o.alias : [o.alias];\r\n\t\tArray.prototype.push.apply(env.classes, aliases);\r\n\t}\r\n\r\n\t_.hooks.run('wrap', env);\r\n\r\n\tvar attributes = Object.keys(env.attributes).map(function(name) {\r\n\t\treturn name + '=\"' + (env.attributes[name] || '').replace(/\"/g, '&quot;') + '\"';\r\n\t}).join(' ');\r\n\r\n\treturn '<' + env.tag + ' class=\"' + env.classes.join(' ') + '\"' + (attributes ? ' ' + attributes : '') + '>' + env.content + '</' + env.tag + '>';\r\n\r\n};\r\n\r\nif (!_self.document) {\r\n\tif (!_self.addEventListener) {\r\n\t\t// in Node.js\r\n\t\treturn _self.Prism;\r\n\t}\r\n\r\n\tif (!_.disableWorkerMessageHandler) {\r\n\t\t// In worker\r\n\t\t_self.addEventListener('message', function (evt) {\r\n\t\t\tvar message = JSON.parse(evt.data),\r\n\t\t\t\tlang = message.language,\r\n\t\t\t\tcode = message.code,\r\n\t\t\t\timmediateClose = message.immediateClose;\r\n\r\n\t\t\t_self.postMessage(_.highlight(code, _.languages[lang], lang));\r\n\t\t\tif (immediateClose) {\r\n\t\t\t\t_self.close();\r\n\t\t\t}\r\n\t\t}, false);\r\n\t}\r\n\r\n\treturn _self.Prism;\r\n}\r\n\r\n//Get current script and highlight\r\nvar script = document.currentScript || [].slice.call(document.getElementsByTagName(\"script\")).pop();\r\n\r\nif (script) {\r\n\t_.filename = script.src;\r\n\r\n\tif (!_.manual && !script.hasAttribute('data-manual')) {\r\n\t\tif(document.readyState !== \"loading\") {\r\n\t\t\tif (window.requestAnimationFrame) {\r\n\t\t\t\twindow.requestAnimationFrame(_.highlightAll);\r\n\t\t\t} else {\r\n\t\t\t\twindow.setTimeout(_.highlightAll, 16);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tdocument.addEventListener('DOMContentLoaded', _.highlightAll);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nreturn _self.Prism;\r\n\r\n})();\r\n\r\nif (typeof module !== 'undefined' && module.exports) {\r\n\tmodule.exports = Prism;\r\n}\r\n\r\n// hack for components to work correctly in node.js\r\nif (typeof global !== 'undefined') {\r\n\tglobal.Prism = Prism;\r\n}\r\n;\r\nPrism.languages.clike = {\r\n\t'comment': [\r\n\t\t{\r\n\t\t\tpattern: /(^|[^\\\\])\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\r\n\t\t\tlookbehind: true\r\n\t\t},\r\n\t\t{\r\n\t\t\tpattern: /(^|[^\\\\:])\\/\\/.*/,\r\n\t\t\tlookbehind: true\r\n\t\t}\r\n\t],\r\n\t'string': {\r\n\t\tpattern: /([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\r\n\t\tgreedy: true\r\n\t},\r\n\t'class-name': {\r\n\t\tpattern: /((?:\\b(?:class|interface|extends|implements|trait|instanceof|new)\\s+)|(?:catch\\s+\\())[\\w.\\\\]+/i,\r\n\t\tlookbehind: true,\r\n\t\tinside: {\r\n\t\t\tpunctuation: /[.\\\\]/\r\n\t\t}\r\n\t},\r\n\t'keyword': /\\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\\b/,\r\n\t'boolean': /\\b(?:true|false)\\b/,\r\n\t'function': /[a-z0-9_]+(?=\\()/i,\r\n\t'number': /\\b-?(?:0x[\\da-f]+|\\d*\\.?\\d+(?:e[+-]?\\d+)?)\\b/i,\r\n\t'operator': /--?|\\+\\+?|!=?=?|<=?|>=?|==?=?|&&?|\\|\\|?|\\?|\\*|\\/|~|\\^|%/,\r\n\t'punctuation': /[{}[\\];(),.:]/\r\n};\r\n\r\nPrism.languages.javascript = Prism.languages.extend('clike', {\r\n\t'keyword': /\\b(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)\\b/,\r\n\t'number': /\\b-?(?:0[xX][\\dA-Fa-f]+|0[bB][01]+|0[oO][0-7]+|\\d*\\.?\\d+(?:[Ee][+-]?\\d+)?|NaN|Infinity)\\b/,\r\n\t// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)\r\n\t'function': /[_$a-z\\xA0-\\uFFFF][$\\w\\xA0-\\uFFFF]*(?=\\s*\\()/i,\r\n\t'operator': /-[-=]?|\\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\\|[|=]?|\\*\\*?=?|\\/=?|~|\\^=?|%=?|\\?|\\.{3}/\r\n});\r\n\r\nPrism.languages.insertBefore('javascript', 'keyword', {\r\n\t'regex': {\r\n\t\tpattern: /(^|[^/])\\/(?!\\/)(\\[[^\\]\\r\\n]+]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[gimyu]{0,5}(?=\\s*($|[\\r\\n,.;})]))/,\r\n\t\tlookbehind: true,\r\n\t\tgreedy: true\r\n\t},\r\n\t// This must be declared before keyword because we use \"function\" inside the look-forward\r\n\t'function-variable': {\r\n\t\tpattern: /[_$a-z\\xA0-\\uFFFF][$\\w\\xA0-\\uFFFF]*(?=\\s*=\\s*(?:function\\b|(?:\\([^()]*\\)|[_$a-z\\xA0-\\uFFFF][$\\w\\xA0-\\uFFFF]*)\\s*=>))/i,\r\n\t\talias: 'function'\r\n\t}\r\n});\r\n\r\nPrism.languages.insertBefore('javascript', 'string', {\r\n\t'template-string': {\r\n\t\tpattern: /`(?:\\\\[\\s\\S]|[^\\\\`])*`/,\r\n\t\tgreedy: true,\r\n\t\tinside: {\r\n\t\t\t'interpolation': {\r\n\t\t\t\tpattern: /\\$\\{[^}]+\\}/,\r\n\t\t\t\tinside: {\r\n\t\t\t\t\t'interpolation-punctuation': {\r\n\t\t\t\t\t\tpattern: /^\\$\\{|\\}$/,\r\n\t\t\t\t\t\talias: 'punctuation'\r\n\t\t\t\t\t},\r\n\t\t\t\t\trest: Prism.languages.javascript\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\t'string': /[\\s\\S]+/\r\n\t\t}\r\n\t}\r\n});\r\n\r\nif (Prism.languages.markup) {\r\n\tPrism.languages.insertBefore('markup', 'tag', {\r\n\t\t'script': {\r\n\t\t\tpattern: /(<script[\\s\\S]*?>)[\\s\\S]*?(?=<\\/script>)/i,\r\n\t\t\tlookbehind: true,\r\n\t\t\tinside: Prism.languages.javascript,\r\n\t\t\talias: 'language-javascript',\r\n\t\t\tgreedy: true\r\n\t\t}\r\n\t});\r\n}\r\n\r\nPrism.languages.js = Prism.languages.javascript;\r\n\r\n(function () {\r\n\r\n\tif (typeof self === 'undefined' || !self.Prism || !self.document) {\r\n\t\treturn;\r\n\t}\r\n\r\n\t/**\r\n\t * Plugin name which is used as a class name for <pre> which is activating the plugin\r\n\t * @type {String}\r\n\t */\r\n\tvar PLUGIN_NAME = 'line-numbers';\r\n\r\n\t/**\r\n\t * Regular expression used for determining line breaks\r\n\t * @type {RegExp}\r\n\t */\r\n\tvar NEW_LINE_EXP = /\\n(?!$)/g;\r\n\r\n\t/**\r\n\t * Resizes line numbers spans according to height of line of code\r\n\t * @param {Element} element <pre> element\r\n\t */\r\n\tvar _resizeElement = function (element) {\r\n\t\tvar codeStyles = getStyles(element);\r\n\t\tvar whiteSpace = codeStyles['white-space'];\r\n\r\n\t\tif (whiteSpace === 'pre-wrap' || whiteSpace === 'pre-line') {\r\n\t\t\tvar codeElement = element.querySelector('code');\r\n\t\t\tvar lineNumbersWrapper = element.querySelector('.line-numbers-rows');\r\n\t\t\tvar lineNumberSizer = element.querySelector('.line-numbers-sizer');\r\n\t\t\tvar codeLines = codeElement.textContent.split(NEW_LINE_EXP);\r\n\r\n\t\t\tif (!lineNumberSizer) {\r\n\t\t\t\tlineNumberSizer = document.createElement('span');\r\n\t\t\t\tlineNumberSizer.className = 'line-numbers-sizer';\r\n\r\n\t\t\t\tcodeElement.appendChild(lineNumberSizer);\r\n\t\t\t}\r\n\r\n\t\t\tlineNumberSizer.style.display = 'block';\r\n\r\n\t\t\tcodeLines.forEach(function (line, lineNumber) {\r\n\t\t\t\tlineNumberSizer.textContent = line || '\\n';\r\n\t\t\t\tvar lineSize = lineNumberSizer.getBoundingClientRect().height;\r\n\t\t\t\tlineNumbersWrapper.children[lineNumber].style.height = lineSize + 'px';\r\n\t\t\t});\r\n\r\n\t\t\tlineNumberSizer.textContent = '';\r\n\t\t\tlineNumberSizer.style.display = 'none';\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Returns style declarations for the element\r\n\t * @param {Element} element\r\n\t */\r\n\tvar getStyles = function (element) {\r\n\t\tif (!element) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\treturn window.getComputedStyle ? getComputedStyle(element) : (element.currentStyle || null);\r\n\t};\r\n\r\n\twindow.addEventListener('resize', function () {\r\n\t\tArray.prototype.forEach.call(document.querySelectorAll('pre.' + PLUGIN_NAME), _resizeElement);\r\n\t});\r\n\r\n\tPrism.hooks.add('complete', function (env) {\r\n\t\tif (!env.code) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// works only for <code> wrapped inside <pre> (not inline)\r\n\t\tvar pre = env.element.parentNode;\r\n\t\tvar clsReg = /\\s*\\bline-numbers\\b\\s*/;\r\n\t\tif (\r\n\t\t\t!pre || !/pre/i.test(pre.nodeName) ||\r\n\t\t\t// Abort only if nor the <pre> nor the <code> have the class\r\n\t\t\t(!clsReg.test(pre.className) && !clsReg.test(env.element.className))\r\n\t\t) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (env.element.querySelector('.line-numbers-rows')) {\r\n\t\t\t// Abort if line numbers already exists\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (clsReg.test(env.element.className)) {\r\n\t\t\t// Remove the class 'line-numbers' from the <code>\r\n\t\t\tenv.element.className = env.element.className.replace(clsReg, ' ');\r\n\t\t}\r\n\t\tif (!clsReg.test(pre.className)) {\r\n\t\t\t// Add the class 'line-numbers' to the <pre>\r\n\t\t\tpre.className += ' line-numbers';\r\n\t\t}\r\n\r\n\t\tvar match = env.code.match(NEW_LINE_EXP);\r\n\t\tvar linesNum = match ? match.length + 1 : 1;\r\n\t\tvar lineNumbersWrapper;\r\n\r\n\t\tvar lines = new Array(linesNum + 1);\r\n\t\tlines = lines.join('<span></span>');\r\n\r\n\t\tlineNumbersWrapper = document.createElement('span');\r\n\t\tlineNumbersWrapper.setAttribute('aria-hidden', 'true');\r\n\t\tlineNumbersWrapper.className = 'line-numbers-rows';\r\n\t\tlineNumbersWrapper.innerHTML = lines;\r\n\r\n\t\tif (pre.hasAttribute('data-start')) {\r\n\t\t\tpre.style.counterReset = 'linenumber ' + (parseInt(pre.getAttribute('data-start'), 10) - 1);\r\n\t\t}\r\n\r\n\t\tenv.element.appendChild(lineNumbersWrapper);\r\n\r\n\t\t_resizeElement(pre);\r\n\r\n\t\tPrism.hooks.run('line-numbers', env);\r\n\t});\r\n\r\n\tPrism.hooks.add('line-numbers', function (env) {\r\n\t\tenv.plugins = env.plugins || {};\r\n\t\tenv.plugins.lineNumbers = true;\r\n\t});\r\n\r\n\t/**\r\n\t * Global exports\r\n\t */\r\n\tPrism.plugins.lineNumbers = {\r\n\t\t/**\r\n\t\t * Get node for provided line number\r\n\t\t * @param {Element} element pre element\r\n\t\t * @param {Number} number line number\r\n\t\t * @return {Element|undefined}\r\n\t\t */\r\n\t\tgetLine: function (element, number) {\r\n\t\t\tif (element.tagName !== 'PRE' || !element.classList.contains(PLUGIN_NAME)) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tvar lineNumberRows = element.querySelector('.line-numbers-rows');\r\n\t\t\tvar lineNumberStart = parseInt(element.getAttribute('data-start'), 10) || 1;\r\n\t\t\tvar lineNumberEnd = lineNumberStart + (lineNumberRows.children.length - 1);\r\n\r\n\t\t\tif (number < lineNumberStart) {\r\n\t\t\t\tnumber = lineNumberStart;\r\n\t\t\t}\r\n\t\t\tif (number > lineNumberEnd) {\r\n\t\t\t\tnumber = lineNumberEnd;\r\n\t\t\t}\r\n\r\n\t\t\tvar lineIndex = number - lineNumberStart;\r\n\r\n\t\t\treturn lineNumberRows.children[lineIndex];\r\n\t\t}\r\n\t};\r\n\r\n}());\r\n(function(){\r\n\tif (typeof self === 'undefined' || !self.Prism || !self.document) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tvar callbacks = [];\r\n\tvar map = {};\r\n\tvar noop = function() {};\r\n\r\n\tPrism.plugins.toolbar = {};\r\n\r\n\t/**\r\n\t * Register a button callback with the toolbar.\r\n\t *\r\n\t * @param {string} key\r\n\t * @param {Object|Function} opts\r\n\t */\r\n\tvar registerButton = Prism.plugins.toolbar.registerButton = function (key, opts) {\r\n\t\tvar callback;\r\n\r\n\t\tif (typeof opts === 'function') {\r\n\t\t\tcallback = opts;\r\n\t\t} else {\r\n\t\t\tcallback = function (env) {\r\n\t\t\t\tvar element;\r\n\r\n\t\t\t\tif (typeof opts.onClick === 'function') {\r\n\t\t\t\t\telement = document.createElement('button');\r\n\t\t\t\t\telement.type = 'button';\r\n\t\t\t\t\telement.addEventListener('click', function () {\r\n\t\t\t\t\t\topts.onClick.call(this, env);\r\n\t\t\t\t\t});\r\n\t\t\t\t} else if (typeof opts.url === 'string') {\r\n\t\t\t\t\telement = document.createElement('a');\r\n\t\t\t\t\telement.href = opts.url;\r\n\t\t\t\t} else {\r\n\t\t\t\t\telement = document.createElement('span');\r\n\t\t\t\t}\r\n\r\n\t\t\t\telement.textContent = opts.text;\r\n\r\n\t\t\t\treturn element;\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tcallbacks.push(map[key] = callback);\r\n\t};\r\n\r\n\t/**\r\n\t * Post-highlight Prism hook callback.\r\n\t *\r\n\t * @param env\r\n\t */\r\n\tvar hook = Prism.plugins.toolbar.hook = function (env) {\r\n\t\t// Check if inline or actual code block (credit to line-numbers plugin)\r\n\t\tvar pre = env.element.parentNode;\r\n\t\tif (!pre || !/pre/i.test(pre.nodeName)) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Autoloader rehighlights, so only do this once.\r\n\t\tif (pre.classList.contains('code-toolbar')) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tpre.classList.add('code-toolbar');\r\n\r\n\t\t// Setup the toolbar\r\n\t\t//var toolbar = document.createElement('div');\r\n\t\t//toolbar.classList.add('toolbar');\r\n\r\n\t\tif (document.body.hasAttribute('data-toolbar-order')) {\r\n\t\t\tcallbacks = document.body.getAttribute('data-toolbar-order').split(',').map(function(key) {\r\n\t\t\t\treturn map[key] || noop;\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tcallbacks.forEach(function(callback) {\r\n\t\t\tvar element = callback(env);\r\n\r\n\t\t\tif (!element) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t//var item = document.createElement('div');\r\n\t\t\t//item.classList.add('toolbar-item');\r\n\r\n\t\t\t//item.appendChild(element);\r\n\t\t\t//toolbar.appendChild(item);\r\n\t\t});\r\n\r\n\t\t// Add our toolbar to the <pre> tag\r\n\t\t//pre.appendChild(toolbar);\r\n\t};\r\n\r\n\tregisterButton('label', function(env) {\r\n\t\tvar pre = env.element.parentNode;\r\n\t\tif (!pre || !/pre/i.test(pre.nodeName)) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (!pre.hasAttribute('data-label')) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar element, template;\r\n\t\tvar text = pre.getAttribute('data-label');\r\n\t\ttry {\r\n\t\t\t// Any normal text will blow up this selector.\r\n\t\t\ttemplate = document.querySelector('template#' + text);\r\n\t\t} catch (e) {}\r\n\r\n\t\tif (template) {\r\n\t\t\telement = template.content;\r\n\t\t} else {\r\n\t\t\tif (pre.hasAttribute('data-url')) {\r\n\t\t\t\telement = document.createElement('a');\r\n\t\t\t\telement.href = pre.getAttribute('data-url');\r\n\t\t\t} else {\r\n\t\t\t\telement = document.createElement('span');\r\n\t\t\t}\r\n\r\n\t\t\telement.textContent = text;\r\n\t\t}\r\n\r\n\t\treturn element;\r\n\t});\r\n\r\n\t/**\r\n\t * Register the toolbar with Prism.\r\n\t */\r\n\tPrism.hooks.add('complete', hook);\r\n})();\r\n\r\n(function () {\r\n\r\n\tif (typeof self === 'undefined' || !self.Prism || !self.document || !Prism.languages.markup) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tPrism.plugins.UnescapedMarkup = true;\r\n\r\n\tPrism.hooks.add('before-highlightall', function (env) {\r\n\t\tenv.selector += \", [class*='lang-'] script[type='text/plain'], [class*='language-'] script[type='text/plain']\" +\r\n\t\t                \", script[type='text/plain'][class*='lang-'], script[type='text/plain'][class*='language-']\";\r\n\t});\r\n\r\n\tPrism.hooks.add('before-sanity-check', function (env) {\r\n\t\tif (env.element.matches(\"script[type='text/plain']\")) {\r\n\t\t\tvar code = document.createElement(\"code\");\r\n\t\t\tvar pre = document.createElement(\"pre\");\r\n\r\n\t\t\tpre.className = code.className = env.element.className;\r\n\r\n\t\t\tif (env.element.dataset) {\r\n\t\t\t\tObject.keys(env.element.dataset).forEach(function (key) {\r\n\t\t\t\t\tif (Object.prototype.hasOwnProperty.call(env.element.dataset, key)) {\r\n\t\t\t\t\t\tpre.dataset[key] = env.element.dataset[key];\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tenv.code = env.code.replace(/&lt;\\/script(>|&gt;)/gi, \"</scri\" + \"pt>\");\r\n\t\t\tcode.textContent = env.code;\r\n\r\n\t\t\tpre.appendChild(code);\r\n\t\t\tenv.element.parentNode.replaceChild(pre, env.element);\r\n\t\t\tenv.element = code;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar pre = env.element.parentNode;\r\n\t\tif (!env.code && pre && pre.nodeName.toLowerCase() == 'pre' &&\r\n\t\t\t\tenv.element.childNodes.length && env.element.childNodes[0].nodeName == \"#comment\") {\r\n\t\t\tenv.element.textContent = env.code = env.element.childNodes[0].textContent;\r\n\t\t}\r\n\t});\r\n}());\r\n\r\n(function() {\r\n\r\nvar assign = Object.assign || function (obj1, obj2) {\r\n\tfor (var name in obj2) {\r\n\t\tif (obj2.hasOwnProperty(name))\r\n\t\t\tobj1[name] = obj2[name];\r\n\t}\r\n\treturn obj1;\r\n}\r\n\r\nfunction NormalizeWhitespace(defaults) {\r\n\tthis.defaults = assign({}, defaults);\r\n}\r\n\r\nfunction toCamelCase(value) {\r\n\treturn value.replace(/-(\\w)/g, function(match, firstChar) {\r\n\t\treturn firstChar.toUpperCase();\r\n\t});\r\n}\r\n\r\nfunction tabLen(str) {\r\n\tvar res = 0;\r\n\tfor (var i = 0; i < str.length; ++i) {\r\n\t\tif (str.charCodeAt(i) == '\\t'.charCodeAt(0))\r\n\t\t\tres += 3;\r\n\t}\r\n\treturn str.length + res;\r\n}\r\n\r\nNormalizeWhitespace.prototype = {\r\n\tsetDefaults: function (defaults) {\r\n\t\tthis.defaults = assign(this.defaults, defaults);\r\n\t},\r\n\tnormalize: function (input, settings) {\r\n\t\tsettings = assign(this.defaults, settings);\r\n\r\n\t\tfor (var name in settings) {\r\n\t\t\tvar methodName = toCamelCase(name);\r\n\t\t\tif (name !== \"normalize\" && methodName !== 'setDefaults' &&\r\n\t\t\t\t\tsettings[name] && this[methodName]) {\r\n\t\t\t\tinput = this[methodName].call(this, input, settings[name]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn input;\r\n\t},\r\n\r\n\t/*\r\n\t * Normalization methods\r\n\t */\r\n\tleftTrim: function (input) {\r\n\t\treturn input.replace(/^\\s+/, '');\r\n\t},\r\n\trightTrim: function (input) {\r\n\t\treturn input.replace(/\\s+$/, '');\r\n\t},\r\n\ttabsToSpaces: function (input, spaces) {\r\n\t\tspaces = spaces|0 || 4;\r\n\t\treturn input.replace(/\\t/g, new Array(++spaces).join(' '));\r\n\t},\r\n\tspacesToTabs: function (input, spaces) {\r\n\t\tspaces = spaces|0 || 4;\r\n\t\treturn input.replace(new RegExp(' {' + spaces + '}', 'g'), '\\t');\r\n\t},\r\n\tremoveTrailing: function (input) {\r\n\t\treturn input.replace(/\\s*?$/gm, '');\r\n\t},\r\n\t// Support for deprecated plugin remove-initial-line-feed\r\n\tremoveInitialLineFeed: function (input) {\r\n\t\treturn input.replace(/^(?:\\r?\\n|\\r)/, '');\r\n\t},\r\n\tremoveIndent: function (input) {\r\n\t\tvar indents = input.match(/^[^\\S\\n\\r]*(?=\\S)/gm);\r\n\r\n\t\tif (!indents || !indents[0].length)\r\n\t\t\treturn input;\r\n\r\n\t\tindents.sort(function(a, b){return a.length - b.length; });\r\n\r\n\t\tif (!indents[0].length)\r\n\t\t\treturn input;\r\n\r\n\t\treturn input.replace(new RegExp('^' + indents[0], 'gm'), '');\r\n\t},\r\n\tindent: function (input, tabs) {\r\n\t\treturn input.replace(/^[^\\S\\n\\r]*(?=\\S)/gm, new Array(++tabs).join('\\t') + '$&');\r\n\t},\r\n\tbreakLines: function (input, characters) {\r\n\t\tcharacters = (characters === true) ? 80 : characters|0 || 80;\r\n\r\n\t\tvar lines = input.split('\\n');\r\n\t\tfor (var i = 0; i < lines.length; ++i) {\r\n\t\t\tif (tabLen(lines[i]) <= characters)\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\tvar line = lines[i].split(/(\\s+)/g),\r\n\t\t\t    len = 0;\r\n\r\n\t\t\tfor (var j = 0; j < line.length; ++j) {\r\n\t\t\t\tvar tl = tabLen(line[j]);\r\n\t\t\t\tlen += tl;\r\n\t\t\t\tif (len > characters) {\r\n\t\t\t\t\tline[j] = '\\n' + line[j];\r\n\t\t\t\t\tlen = tl;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tlines[i] = line.join('');\r\n\t\t}\r\n\t\treturn lines.join('\\n');\r\n\t}\r\n};\r\n\r\n// Support node modules\r\nif (typeof module !== 'undefined' && module.exports) {\r\n\tmodule.exports = NormalizeWhitespace;\r\n}\r\n\r\n// Exit if prism is not loaded\r\nif (typeof Prism === 'undefined') {\r\n\treturn;\r\n}\r\n\r\nPrism.plugins.NormalizeWhitespace = new NormalizeWhitespace({\r\n\t'remove-trailing': true,\r\n\t'remove-indent': true,\r\n\t'left-trim': true,\r\n\t'right-trim': true,\r\n\t/*'break-lines': 80,\r\n\t'indent': 2,\r\n\t'remove-initial-line-feed': false,\r\n\t'tabs-to-spaces': 4,\r\n\t'spaces-to-tabs': 4*/\r\n});\r\n\r\nPrism.hooks.add('before-sanity-check', function (env) {\r\n\tvar Normalizer = Prism.plugins.NormalizeWhitespace;\r\n\r\n\t// Check settings\r\n\tif (env.settings && env.settings['whitespace-normalization'] === false) {\r\n\t\treturn;\r\n\t}\r\n\r\n\t// Simple mode if there is no env.element\r\n\tif ((!env.element || !env.element.parentNode) && env.code) {\r\n\t\tenv.code = Normalizer.normalize(env.code, env.settings);\r\n\t\treturn;\r\n\t}\r\n\r\n\t// Normal mode\r\n\tvar pre = env.element.parentNode;\r\n\tvar clsReg = /\\bno-whitespace-normalization\\b/;\r\n\tif (!env.code || !pre || pre.nodeName.toLowerCase() !== 'pre' ||\r\n\t\t\tclsReg.test(pre.className) || clsReg.test(env.element.className))\r\n\t\treturn;\r\n\r\n\tvar children = pre.childNodes,\r\n\t    before = '',\r\n\t    after = '',\r\n\t    codeFound = false;\r\n\r\n\t// Move surrounding whitespace from the <pre> tag into the <code> tag\r\n\tfor (var i = 0; i < children.length; ++i) {\r\n\t\tvar node = children[i];\r\n\r\n\t\tif (node == env.element) {\r\n\t\t\tcodeFound = true;\r\n\t\t} else if (node.nodeName === \"#text\") {\r\n\t\t\tif (codeFound) {\r\n\t\t\t\tafter += node.nodeValue;\r\n\t\t\t} else {\r\n\t\t\t\tbefore += node.nodeValue;\r\n\t\t\t}\r\n\r\n\t\t\tpre.removeChild(node);\r\n\t\t\t--i;\r\n\t\t}\r\n\t}\r\n\r\n\tif (!env.element.children.length || !Prism.plugins.KeepMarkup) {\r\n\t\tenv.code = before + env.code + after;\r\n\t\tenv.code = Normalizer.normalize(env.code, env.settings);\r\n\t} else {\r\n\t\t// Preserve markup for keep-markup plugin\r\n\t\tvar html = before + env.element.innerHTML + after;\r\n\t\tenv.element.innerHTML = Normalizer.normalize(html, env.settings);\r\n\t\tenv.code = env.element.textContent;\r\n\t}\r\n});\r\n\r\n}());\r\n(function(){\r\n\tif (typeof self === 'undefined' || !self.Prism || !self.document) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (!Prism.plugins.toolbar) {\r\n\t\tconsole.warn('Copy to Clipboard plugin loaded before Toolbar plugin.');\r\n\r\n\t\treturn;\r\n\t}\r\n\r\n\tvar Clipboard = window.Clipboard || undefined;\r\n\r\n\tif (Clipboard && /(native code)/.test(Clipboard.toString())) {\r\n\t\tClipboard = undefined;\r\n\t}\r\n\r\n\tif (!Clipboard && typeof require === 'function') {\r\n\t\tClipboard = require('clipboard');\r\n\t}\r\n\r\n\tvar callbacks = [];\r\n\r\n\tif (!Clipboard) {\r\n\t\tvar script = document.createElement('script');\r\n\t\tvar head = document.querySelector('head');\r\n\r\n\t\tscript.onload = function() {\r\n\t\t\tClipboard = window.Clipboard;\r\n\r\n\t\t\tif (Clipboard) {\r\n\t\t\t\twhile (callbacks.length) {\r\n\t\t\t\t\tcallbacks.pop()();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.7.1/clipboard.min.js';\r\n\t\thead.appendChild(script);\r\n\t}\r\n\r\n\tPrism.plugins.toolbar.registerButton('copy-to-clipboard', function (env) {\r\n\t\tvar linkCopy = document.getElementById('copyButton');\r\n\r\n\t\t//var linkCopy = document.createElement('a');\r\n\t\t//linkCopy.textContent = 'Copy';\r\n\r\n\t\tif (!Clipboard) {\r\n\t\t\tcallbacks.push(registerClipboard);\r\n\t\t} else {\r\n\t\t\tregisterClipboard();\r\n\t\t}\r\n\r\n\t\treturn linkCopy;\r\n\r\n\t\tfunction registerClipboard() {\r\n\t\t\tvar clip = new Clipboard(linkCopy, {\r\n\t\t\t\t'text': function () {\r\n\t\t\t\t\treturn env.code;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tclip.on('success', function() {\r\n\t\t\t\tlinkCopy.children[1].innerText = 'Copied';\r\n\r\n\t\t\t\tresetText();\r\n\t\t\t});\r\n\t\t\tclip.on('error', function () {\r\n\t\t\t\tlinkCopy.children[1].innerText = 'Press Ctrl+C to copy';\r\n\r\n\t\t\t\tresetText();\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tfunction resetText() {\r\n\t\t\tsetTimeout(function () {\r\n\t\t\t\tlinkCopy.children[1].innerText = 'Copy';\r\n\t\t\t}, 3000);\r\n\t\t}\r\n\t});\r\n})();\r\n\n\n\n// WEBPACK FOOTER //\n// src/prism/prism.js"],"sourceRoot":"webpack:///"}